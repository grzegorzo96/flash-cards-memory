-- =====================================================
-- Migration: Initial Schema for FlashCardMemory
-- =====================================================
-- Purpose: Create the complete database schema for the flashcard application
-- Tables: decks, generation_requests, flashcards, study_sessions, review_events
-- Features: ENUM types, RLS policies, indexes, soft-delete support
-- Special considerations: 
--   - All tables have RLS enabled with user_id-based policies
--   - Soft-delete implemented via deleted_at for decks and flashcards
--   - Full-text search index on flashcards
--   - FSRS algorithm parameters stored in review_events
-- =====================================================

-- =====================================================
-- SECTION 1: ENUM TYPES
-- =====================================================

-- language_code: supported languages for flashcards
-- currently limited to Polish and English for MVP
create type language_code as enum ('pl', 'en');

-- flashcard_source: origin of the flashcard
-- 'ai' = generated by AI, 'manual' = created by user
create type flashcard_source as enum ('ai', 'manual');

-- generation_status: status of AI generation requests
-- tracks the lifecycle of flashcard generation from request to completion
create type generation_status as enum ('pending', 'processing', 'completed', 'failed');

-- study_session_status: status of a study session
-- tracks whether a session is active, completed normally, or abandoned
create type study_session_status as enum ('in_progress', 'completed', 'abandoned');

-- =====================================================
-- SECTION 2: TABLES
-- =====================================================

-- -----------------------------------------------------
-- Table: decks
-- -----------------------------------------------------
-- Purpose: Store collections of flashcards organized by user
-- Features: 
--   - Soft-delete via deleted_at for analytics and audit
--   - Unique constraint on (user_id, name) to prevent duplicate deck names per user
--   - Minimum name length of 3 characters
-- -----------------------------------------------------
create table decks (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  description text null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  deleted_at timestamptz null,
  
  -- ensure unique deck names per user
  constraint decks_user_id_name_unique unique (user_id, name),
  
  -- enforce minimum name length
  constraint decks_name_length_check check (char_length(name) >= 3)
);

-- enable row level security
alter table decks enable row level security;

-- -----------------------------------------------------
-- Table: generation_requests
-- -----------------------------------------------------
-- Purpose: Track AI flashcard generation requests
-- Features:
--   - Stores source text (max 5000 characters) for AI processing
--   - Links to deck if flashcards are accepted
--   - Tracks status, errors, and timing
--   - deck_id can be null if flashcards not yet accepted
-- -----------------------------------------------------
create table generation_requests (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  deck_id uuid null references decks(id) on delete set null,
  source_text text not null,
  domain text not null,
  source_language language_code not null,
  target_language language_code not null,
  status generation_status not null default 'pending',
  error_code text null,
  error_message text null,
  requested_at timestamptz not null default now(),
  completed_at timestamptz null,
  
  -- enforce source text length limits (1-5000 characters)
  constraint generation_requests_source_text_length_check check (char_length(source_text) between 1 and 5000)
);

-- enable row level security
alter table generation_requests enable row level security;

-- -----------------------------------------------------
-- Table: flashcards
-- -----------------------------------------------------
-- Purpose: Store individual flashcards with questions and answers
-- Features:
--   - Soft-delete via deleted_at for analytics
--   - Stores original AI-generated content before user edits
--   - Tracks acceptance status for AI-generated cards
--   - Supports spaced repetition with due dates
--   - Links to generation request if AI-generated
-- -----------------------------------------------------
create table flashcards (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  deck_id uuid not null references decks(id) on delete cascade,
  generation_request_id uuid null references generation_requests(id) on delete set null,
  question text not null,
  answer text not null,
  original_question text null,
  original_answer text null,
  source flashcard_source not null,
  is_accepted boolean not null default false,
  source_language language_code not null,
  target_language language_code not null,
  last_reviewed_at timestamptz null,
  next_due_at timestamptz null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  deleted_at timestamptz null,
  
  -- enforce question length limits (1-2000 characters)
  constraint flashcards_question_length_check check (char_length(question) between 1 and 2000),
  
  -- enforce answer length limits (1-2000 characters)
  constraint flashcards_answer_length_check check (char_length(answer) between 1 and 2000)
);

-- enable row level security
alter table flashcards enable row level security;

-- -----------------------------------------------------
-- Table: study_sessions
-- -----------------------------------------------------
-- Purpose: Track user study sessions for a deck
-- Features:
--   - Records start and end times
--   - Tracks session status (in_progress, completed, abandoned)
--   - Links review events to study sessions
-- -----------------------------------------------------
create table study_sessions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  deck_id uuid not null references decks(id) on delete cascade,
  started_at timestamptz not null default now(),
  ended_at timestamptz null,
  status study_session_status not null default 'in_progress',
  created_at timestamptz not null default now()
);

-- enable row level security
alter table study_sessions enable row level security;

-- -----------------------------------------------------
-- Table: review_events
-- -----------------------------------------------------
-- Purpose: Store individual flashcard review events with FSRS parameters
-- Features:
--   - Records user rating (1-4 scale)
--   - Stores FSRS algorithm parameters per event
--   - Links to study session if part of a session
--   - Tracks scheduling and timing data
-- Note: FSRS parameters are calculated per event, no global weights stored
-- -----------------------------------------------------
create table review_events (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  flashcard_id uuid not null references flashcards(id) on delete cascade,
  study_session_id uuid null references study_sessions(id) on delete set null,
  rating smallint not null,
  reviewed_at timestamptz not null default now(),
  scheduled_days integer null,
  elapsed_days integer null,
  stability numeric(6,2) null,
  difficulty numeric(5,2) null,
  retrievability numeric(5,4) null,
  next_due_at timestamptz null,
  
  -- enforce rating range (1-4 for FSRS algorithm)
  constraint review_events_rating_check check (rating between 1 and 4)
);

-- enable row level security
alter table review_events enable row level security;

-- =====================================================
-- SECTION 3: INDEXES
-- =====================================================

-- decks: unique index for user_id and name combination
-- already created via unique constraint above

-- flashcards: index for deck lookups
create index flashcards_deck_id_idx on flashcards(deck_id);

-- flashcards: index for finding due cards per user
create index flashcards_user_id_next_due_at_idx on flashcards(user_id, next_due_at);

-- flashcards: index for finding recently reviewed cards per user
create index flashcards_user_id_last_reviewed_at_idx on flashcards(user_id, last_reviewed_at);

-- flashcards: full-text search index for question and answer content
-- using 'simple' dictionary to avoid language-specific stemming
create index flashcards_search_idx on flashcards using gin(to_tsvector('simple', coalesce(question,'') || ' ' || coalesce(answer,'')));

-- review_events: index for flashcard review history
create index review_events_flashcard_id_reviewed_at_idx on review_events(flashcard_id, reviewed_at);

-- review_events: index for study session lookups
create index review_events_study_session_id_idx on review_events(study_session_id);

-- generation_requests: index for user request history
create index generation_requests_user_id_requested_at_idx on generation_requests(user_id, requested_at);

-- =====================================================
-- SECTION 4: ROW LEVEL SECURITY POLICIES
-- =====================================================

-- -----------------------------------------------------
-- RLS Policies: decks
-- -----------------------------------------------------
-- Rationale: Users can only access their own decks
-- All operations (select, insert, update, delete) are restricted to user_id = auth.uid()
-- -----------------------------------------------------

-- policy: authenticated users can select their own decks
create policy "decks_select_policy_authenticated"
  on decks
  for select
  to authenticated
  using (user_id = auth.uid());

-- policy: authenticated users can insert their own decks
create policy "decks_insert_policy_authenticated"
  on decks
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- policy: authenticated users can update their own decks
create policy "decks_update_policy_authenticated"
  on decks
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- policy: authenticated users can delete their own decks
create policy "decks_delete_policy_authenticated"
  on decks
  for delete
  to authenticated
  using (user_id = auth.uid());

-- -----------------------------------------------------
-- RLS Policies: generation_requests
-- -----------------------------------------------------
-- Rationale: Users can only access their own generation requests
-- All operations are restricted to user_id = auth.uid()
-- -----------------------------------------------------

-- policy: authenticated users can select their own generation requests
create policy "generation_requests_select_policy_authenticated"
  on generation_requests
  for select
  to authenticated
  using (user_id = auth.uid());

-- policy: authenticated users can insert their own generation requests
create policy "generation_requests_insert_policy_authenticated"
  on generation_requests
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- policy: authenticated users can update their own generation requests
create policy "generation_requests_update_policy_authenticated"
  on generation_requests
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- policy: authenticated users can delete their own generation requests
create policy "generation_requests_delete_policy_authenticated"
  on generation_requests
  for delete
  to authenticated
  using (user_id = auth.uid());

-- -----------------------------------------------------
-- RLS Policies: flashcards
-- -----------------------------------------------------
-- Rationale: Users can only access their own flashcards
-- All operations are restricted to user_id = auth.uid()
-- -----------------------------------------------------

-- policy: authenticated users can select their own flashcards
create policy "flashcards_select_policy_authenticated"
  on flashcards
  for select
  to authenticated
  using (user_id = auth.uid());

-- policy: authenticated users can insert their own flashcards
create policy "flashcards_insert_policy_authenticated"
  on flashcards
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- policy: authenticated users can update their own flashcards
create policy "flashcards_update_policy_authenticated"
  on flashcards
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- policy: authenticated users can delete their own flashcards
create policy "flashcards_delete_policy_authenticated"
  on flashcards
  for delete
  to authenticated
  using (user_id = auth.uid());

-- -----------------------------------------------------
-- RLS Policies: study_sessions
-- -----------------------------------------------------
-- Rationale: Users can only access their own study sessions
-- All operations are restricted to user_id = auth.uid()
-- -----------------------------------------------------

-- policy: authenticated users can select their own study sessions
create policy "study_sessions_select_policy_authenticated"
  on study_sessions
  for select
  to authenticated
  using (user_id = auth.uid());

-- policy: authenticated users can insert their own study sessions
create policy "study_sessions_insert_policy_authenticated"
  on study_sessions
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- policy: authenticated users can update their own study sessions
create policy "study_sessions_update_policy_authenticated"
  on study_sessions
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- policy: authenticated users can delete their own study sessions
create policy "study_sessions_delete_policy_authenticated"
  on study_sessions
  for delete
  to authenticated
  using (user_id = auth.uid());

-- -----------------------------------------------------
-- RLS Policies: review_events
-- -----------------------------------------------------
-- Rationale: Users can only access their own review events
-- All operations are restricted to user_id = auth.uid()
-- -----------------------------------------------------

-- policy: authenticated users can select their own review events
create policy "review_events_select_policy_authenticated"
  on review_events
  for select
  to authenticated
  using (user_id = auth.uid());

-- policy: authenticated users can insert their own review events
create policy "review_events_insert_policy_authenticated"
  on review_events
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- policy: authenticated users can update their own review events
create policy "review_events_update_policy_authenticated"
  on review_events
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- policy: authenticated users can delete their own review events
create policy "review_events_delete_policy_authenticated"
  on review_events
  for delete
  to authenticated
  using (user_id = auth.uid());

-- =====================================================
-- MIGRATION COMPLETE
-- =====================================================
-- Summary:
--   - 4 ENUM types created
--   - 5 tables created with RLS enabled
--   - 8 indexes created for performance
--   - 20 RLS policies created (4 per table: select, insert, update, delete)
-- Next steps:
--   - Create RPC functions for aggregations and statistics
--   - Implement soft-delete cleanup procedures if needed
--   - Add triggers for updated_at automation if desired
-- =====================================================
